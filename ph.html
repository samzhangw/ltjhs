<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI å…­é‚Šå½¢æ­¸é¡å™¨ (é›™æ¨¡å¼åˆ†æç‰ˆ)</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style>
        :root {
            --primary: #4f46e5;
            --surface: rgba(255, 255, 255, 0.95);
            --bg-gradient: linear-gradient(135deg, #e0e7ff 0%, #fae8ff 100%);
            --border: #cbd5e1;
            --text: #1e293b;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-gradient);
            color: var(--text);
            margin: 0;
            padding: 40px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            background: var(--surface);
            padding: 2.5rem;
            border-radius: 20px;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.6);
        }

        header { text-align: center; margin-bottom: 2rem; }
        h1 { margin: 0; color: var(--primary); font-size: 2rem; }
        .desc { color: #64748b; margin-top: 0.5rem; }

        /* Mode Switcher Toggle */
        .mode-switch {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            background: #f1f5f9;
            padding: 5px;
            border-radius: 12px;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }
        .mode-option {
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s;
            color: #64748b;
        }
        .mode-option.active {
            background: white;
            color: var(--primary);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Upload Area */
        .upload-area {
            border: 3px dashed #94a3b8;
            border-radius: 12px;
            padding: 3rem;
            text-align: center;
            cursor: pointer;
            background: #f8fafc;
            transition: 0.2s;
        }
        .upload-area:hover { border-color: var(--primary); background: #eff6ff; }
        .upload-icon { font-size: 3rem; margin-bottom: 1rem; display: block; }

        /* Controls */
        .controls {
            display: flex; gap: 20px; justify-content: center; margin: 20px 0; flex-wrap: wrap;
            background: #f8fafc; padding: 15px; border-radius: 10px; border: 1px solid var(--border);
        }
        .control-item { display: flex; align-items: center; gap: 8px; font-size: 0.9rem; font-weight: 500; }
        input[type="number"] { width: 60px; padding: 6px; border-radius: 6px; border: 1px solid #ccc; text-align: center; }

        /* Buttons */
        .btn-group { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
        button {
            padding: 12px 24px; border: none; border-radius: 10px; cursor: pointer; color: white; font-weight: 600;
            transition: 0.2s; display: flex; align-items: center; gap: 8px; font-size: 1rem;
        }
        .btn-primary { background: var(--primary); box-shadow: 0 4px 6px -1px rgba(79, 70, 229, 0.3); }
        .btn-excel { background: #10b981; display: none; }
        .btn-zip { background: #f59e0b; display: none; }
        button:disabled { background: #cbd5e1; cursor: not-allowed; box-shadow: none; }
        button:hover:not(:disabled) { transform: translateY(-2px); filter: brightness(1.1); }

        .progress-bar {
            height: 6px; background: var(--primary); width: 0%; margin-top: 20px; border-radius: 3px; transition: width 0.3s;
        }

        /* Results */
        .results { margin-top: 30px; display: grid; gap: 20px; }
        .group-block {
            background: white; border: 1px solid var(--border); border-radius: 12px; overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05); animation: fadeIn 0.5s;
        }
        .group-header {
            padding: 12px 20px; background: #f8fafc; border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
        }
        .group-title { font-weight: 700; color: #334155; }
        .tag { padding: 4px 10px; border-radius: 20px; font-size: 0.8rem; font-weight: bold; }
        .tag-blue { background: #e0e7ff; color: var(--primary); }
        
        .group-content {
            padding: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 12px;
            max-height: 400px; overflow-y: auto;
        }
        .img-card { text-align: center; cursor: pointer; transition: 0.2s; }
        .img-card:hover { transform: translateY(-4px); }
        .img-thumb {
            width: 100%; aspect-ratio: 1; object-fit: contain; border: 1px solid #eee; border-radius: 8px; padding: 4px;
        }
        .img-name { font-size: 11px; color: #64748b; margin-top: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        /* Modal */
        .modal {
            display: none; position: fixed; z-index: 999; left: 0; top: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.9); align-items: center; justify-content: center; backdrop-filter: blur(4px);
        }
        .modal img { max-width: 90%; max-height: 90%; border-radius: 8px; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.5); }
        .modal-close { position: absolute; top: 20px; right: 30px; color: white; font-size: 40px; cursor: pointer; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>AI å…­é‚Šå½¢æ­¸é¡å™¨ (é›™æ¨¡å¼)</h1>
        <p class="desc">æ”¯æ´ã€Œå¿½ç•¥é¡è‰²ã€èˆ‡ã€Œå€åˆ†é¡è‰²ã€å…©ç¨®åˆ†ææ–¹å¼</p>
    </header>

    <div class="mode-switch">
        <div class="mode-option active" id="modeStructure" onclick="setMode('structure')">
            ğŸ“ åƒ…çµæ§‹ (å¿½ç•¥é¡è‰²)
        </div>
        <div class="mode-option" id="modeColor" onclick="setMode('color')">
            ğŸ¨ çµæ§‹ + é¡è‰² (å€åˆ†ç´…è—)
        </div>
    </div>

    <div class="upload-area" id="dropZone">
        <div class="upload-icon">ğŸ“‚</div>
        <h3>æ‹–æ›³åœ–ç‰‡åˆ°é€™è£¡</h3>
        <p>æ¼”ç®—æ³•æœƒè‡ªå‹•è£åˆ‡ã€å±…ä¸­ä¸¦åˆ†æç‰¹å¾µ</p>
        <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
    </div>

    <div class="controls">
        <div class="control-item">
            <label title="è¨­ç‚º 0 è¡¨ç¤ºå®Œå…¨ç›¸åŒæ‰åˆ†ä¸€çµ„">å®¹è¨±å·®ç•° (Distance):</label>
            <input type="number" id="thresholdInput" value="3" min="0" max="20">
        </div>
        <div class="control-item">
            <label title="ç‰¹å¾µç¶²æ ¼å¤§å°ï¼Œå»ºè­° 16">ç‰¹å¾µç²¾åº¦ (Hash Size):</label>
            <input type="number" id="hashSizeInput" value="16" min="8" max="32">
        </div>
    </div>

    <div class="btn-group">
        <button id="processBtn" class="btn-primary" disabled>ğŸš€ é–‹å§‹åˆ†æ</button>
        <button id="excelBtn" class="btn-excel">ğŸ“Š ä¸‹è¼‰ Excel</button>
        <button id="zipBtn" class="btn-zip">ğŸ“¦ ä¸‹è¼‰ ZIP</button>
    </div>

    <div id="progressWrap" style="display: none; width: 100%;">
        <div class="progress-bar" id="progressBar"></div>
    </div>
    <div id="statusLog" style="text-align: center; margin-top: 15px; color: #64748b; font-size: 0.9rem;">æº–å‚™å°±ç·’</div>

    <div id="resultsArea" class="results"></div>
</div>

<div id="imgModal" class="modal" onclick="this.style.display='none'">
    <span class="modal-close">&times;</span>
    <img id="modalImg">
</div>

<script>
    // --- è®Šæ•¸èˆ‡è¨­å®š ---
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const processBtn = document.getElementById('processBtn');
    const excelBtn = document.getElementById('excelBtn');
    const zipBtn = document.getElementById('zipBtn');
    const statusLog = document.getElementById('statusLog');
    const progressBar = document.getElementById('progressBar');
    const resultsArea = document.getElementById('resultsArea');
    const modal = document.getElementById('imgModal');
    const modalImg = document.getElementById('modalImg');

    let selectedFiles = [];
    let processingGroups = [];
    let currentMode = 'structure'; // 'structure' or 'color'

    const ANGLES = [0, 60, 120, 180, 240, 300];
    const WHITE_THRESHOLD = 200; // åˆ¤å®šæ˜¯å¦ç‚ºèƒŒæ™¯

    // --- äº‹ä»¶ç¶å®š ---
    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.borderColor = '#4f46e5'; dropZone.style.background = '#eef2ff'; });
    dropZone.addEventListener('dragleave', () => { dropZone.style.borderColor = '#94a3b8'; dropZone.style.background = '#f8fafc'; });
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.style.borderColor = '#94a3b8'; dropZone.style.background = '#f8fafc'; handleFiles(e.dataTransfer.files); });
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
    
    processBtn.addEventListener('click', startAnalysis);
    excelBtn.addEventListener('click', downloadExcel);
    zipBtn.addEventListener('click', downloadZip);

    // --- åŠŸèƒ½å‡½å¼ ---

    function setMode(mode) {
        currentMode = mode;
        document.getElementById('modeStructure').className = mode === 'structure' ? 'mode-option active' : 'mode-option';
        document.getElementById('modeColor').className = mode === 'color' ? 'mode-option active' : 'mode-option';
        
        if (selectedFiles.length > 0) {
            statusLog.textContent = `å·²åˆ‡æ›è‡³ã€Œ${mode === 'structure' ? 'åƒ…çµæ§‹' : 'çµæ§‹+é¡è‰²'}ã€æ¨¡å¼ï¼Œè«‹é»æ“Šé–‹å§‹åˆ†æã€‚`;
            resultsArea.innerHTML = ''; // æ¸…ç©ºèˆŠçµæœ
            excelBtn.style.display = 'none';
            zipBtn.style.display = 'none';
        }
    }

    function handleFiles(files) {
        const imgs = Array.from(files).filter(f => f.type.startsWith('image/'));
        if (!imgs.length) return;
        selectedFiles = [...selectedFiles, ...imgs];
        statusLog.textContent = `âœ… å·²è¼‰å…¥ ${selectedFiles.length} å¼µåœ–ç‰‡`;
        processBtn.disabled = false;
        excelBtn.style.display = 'none';
        zipBtn.style.display = 'none';
        resultsArea.innerHTML = '';
    }

    function loadImage(file) {
        return new Promise(resolve => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.src = URL.createObjectURL(file);
        });
    }

    /**
     * é è™•ç†ï¼šè‡ªå‹•è£åˆ‡ä¸¦å±…ä¸­ (ä¿ç•™åŸå§‹è‰²å½©)
     * æ³¨æ„ï¼šé€™è£¡ä¸é€²è¡ŒäºŒå€¼åŒ–ï¼Œåªè² è²¬æŠŠåœ–å½¢æ”¾åœ¨æ­£ä¸­é–“ï¼ŒäºŒå€¼åŒ–æˆ–è‰²å½©åˆ†æç•™çµ¦ Hash å‡½æ•¸
     */
    function preprocessImage(img, targetSize) {
        const w = img.naturalWidth, h = img.naturalHeight;
        
        // 1. åµæ¸¬å…§å®¹é‚Šç•Œ (Bounding Box) - ä½¿ç”¨äº®åº¦åˆ¤æ–·
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = w; tempCanvas.height = h;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const data = ctx.getImageData(0, 0, w, h).data;

        let minX = w, minY = h, maxX = 0, maxY = 0;
        let hasContent = false;

        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const i = (y * w + x) * 4;
                const r = data[i], g = data[i+1], b = data[i+2];
                // ç°¡å–®äº®åº¦è¨ˆç®—ï¼Œåªè¦ä¸æ˜¯å…¨ç™½å°±ç®—å…§å®¹
                if ((r + g + b) / 3 < 240) { 
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                    hasContent = true;
                }
            }
        }

        if (!hasContent) { minX = 0; minY = 0; maxX = w; maxY = h; }

        // 2. è£åˆ‡ä¸¦å±…ä¸­ç¸®æ”¾åˆ°ç›®æ¨™å¤§å°
        const contentW = maxX - minX + 1;
        const contentH = maxY - minY + 1;
        const maxDim = Math.max(contentW, contentH);
        
        const finalCanvas = document.createElement('canvas');
        finalCanvas.width = targetSize;
        finalCanvas.height = targetSize;
        const fCtx = finalCanvas.getContext('2d');

        // å¡«æ»¿ç™½åº•
        fCtx.fillStyle = '#FFFFFF';
        fCtx.fillRect(0, 0, targetSize, targetSize);

        const padding = targetSize * 0.1; 
        const scale = (targetSize - padding * 2) / maxDim;

        fCtx.drawImage(
            tempCanvas,
            minX, minY, contentW, contentH,
            (targetSize - contentW * scale) / 2, (targetSize - contentH * scale) / 2,
            contentW * scale, contentH * scale
        );

        return finalCanvas;
    }

    function getRotatedCanvas(source, angle) {
        if (angle === 0) return source;
        const size = source.width;
        const c = document.createElement('canvas');
        c.width = size; c.height = size;
        const ctx = c.getContext('2d');
        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, size, size);
        ctx.translate(size/2, size/2);
        ctx.rotate(angle * Math.PI / 180);
        ctx.drawImage(source, -size/2, -size/2);
        return c;
    }

    /**
     * è¨ˆç®—ç‰¹å¾µæŒ‡ç´‹ (æ”¯æ´é›™æ¨¡å¼)
     */
    function calculateHash(canvas, hashSize, mode) {
        const c = document.createElement('canvas');
        c.width = hashSize; c.height = hashSize;
        const ctx = c.getContext('2d');
        ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(canvas, 0, 0, hashSize, hashSize);
        
        const data = ctx.getImageData(0, 0, hashSize, hashSize).data;
        let result = "";

        if (mode === 'structure') {
            // --- æ¨¡å¼ Aï¼šçµæ§‹å„ªå…ˆ (é»‘ç™½) ---
            // è¨ˆç®—å¹³å‡äº®åº¦
            let sum = 0;
            let pixels = [];
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114;
                pixels.push(gray);
                sum += gray;
            }
            const avg = sum / pixels.length;
            // è½‰æˆ 0/1 å­—ä¸²
            result = pixels.map(p => p > avg ? '1' : '0').join('');

        } else {
            // --- æ¨¡å¼ Bï¼šè‰²å½©æ•æ„Ÿ (åˆ†è¾¨ ç´…/è—/é»‘/ç™½) ---
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                const brightness = (r + g + b) / 3;

                // ç°¡å–®çš„è‰²å½©é‡åŒ–é‚è¼¯
                if (brightness > 220) {
                    result += "0"; // èƒŒæ™¯(ç™½)
                } else if (r > g + 30 && r > b + 30) {
                    result += "1"; // ç´…è‰²ä¸»å°
                } else if (b > r + 30 && b > g + 30) {
                    result += "2"; // è—è‰²ä¸»å°
                } else {
                    result += "3"; // å…¶ä»–æ·±è‰²(é»‘/ç°)
                }
            }
        }
        return result;
    }

    function hammingDistance(s1, s2) {
        let dist = 0;
        for(let i=0; i<s1.length; i++) if(s1[i]!==s2[i]) dist++;
        return dist;
    }

    async function startAnalysis() {
        if (!selectedFiles.length) return;
        processBtn.disabled = true;
        document.getElementById('progressWrap').style.display = 'block';
        resultsArea.innerHTML = '';

        const hashSize = parseInt(document.getElementById('hashSizeInput').value) || 16;
        const threshold = parseInt(document.getElementById('thresholdInput').value) || 3;
        const PROCESSING_SIZE = 200; // å…§éƒ¨è£åˆ‡è™•ç†è§£æåº¦

        let fileData = [];

        // 1. ç‰¹å¾µæå–
        for(let i=0; i<selectedFiles.length; i++){
            statusLog.textContent = `æå–ç‰¹å¾µ (${currentMode === 'color' ? 'å«é¡è‰²' : 'åƒ…çµæ§‹'}): ${selectedFiles[i].name}`;
            progressBar.style.width = `${((i+1)/selectedFiles.length)*50}%`;

            try {
                const img = await loadImage(selectedFiles[i]);
                // é è™•ç† (ä¿ç•™é¡è‰²ï¼Œåªåšè£åˆ‡)
                const baseCanvas = preprocessImage(img, PROCESSING_SIZE);
                
                let minHash = null;
                // æ—‹è½‰ 6 æ¬¡å–æœ€å° Hash (è§£æ±ºè§’åº¦å•é¡Œ)
                for(const angle of ANGLES) {
                    const rot = getRotatedCanvas(baseCanvas, angle);
                    // æ ¹æ“šæ¨¡å¼è¨ˆç®— Hash
                    const h = calculateHash(rot, hashSize, currentMode);
                    
                    // æ‰¾å‡ºã€Œå­—å…¸åºã€æœ€å°çš„å­—ä¸²ä½œç‚ºä»£è¡¨
                    if(minHash === null || h < minHash) minHash = h;
                }
                fileData.push({ file: selectedFiles[i], hash: minHash, name: selectedFiles[i].name });
            } catch(e) { console.error(e); }
            
            // è®“ UI å–˜å£æ°£
            await new Promise(r => setTimeout(r, 0));
        }

        // 2. åˆ†ç¾¤
        statusLog.textContent = "æ­£åœ¨é€²è¡Œæ¯”å°...";
        let groups = [];
        for(let i=0; i<fileData.length; i++){
            const item = fileData[i];
            let match = null;
            for(let g of groups) {
                if(hammingDistance(item.hash, g.repHash) <= threshold) { match = g; break; }
            }
            if(match) match.files.push(item);
            else groups.push({ repHash: item.hash, files: [item] });
            progressBar.style.width = `${50 + ((i+1)/fileData.length)*50}%`;
        }

        groups.sort((a,b) => b.files.length - a.files.length);
        processingGroups = groups;
        renderResults(groups);

        statusLog.textContent = `å®Œæˆï¼å…±åˆ†ç‚º ${groups.length} çµ„ (${currentMode === 'structure' ? 'çµæ§‹' : 'è‰²å½©'}æ¨¡å¼)`;
        processBtn.disabled = false;
        processBtn.textContent = 'é‡æ–°åˆ†æ';
        excelBtn.style.display = 'block';
        zipBtn.style.display = 'block';
    }

    function renderResults(groups) {
        resultsArea.innerHTML = '';
        groups.forEach((g, idx) => {
            const div = document.createElement('div');
            div.className = 'group-block';
            div.innerHTML = `
                <div class="group-header">
                    <span class="group-title">ç¾¤çµ„ ${idx+1}</span>
                    <span class="tag tag-blue">${g.files.length} å¼µ</span>
                </div>
                <div class="group-content"></div>
            `;
            const content = div.querySelector('.group-content');
            g.files.forEach(f => {
                const card = document.createElement('div');
                card.className = 'img-card';
                card.onclick = () => { modal.style.display='flex'; modalImg.src=URL.createObjectURL(f.file); };
                card.innerHTML = `<img class="img-thumb" src="${URL.createObjectURL(f.file)}"><div class="img-name">${f.name}</div>`;
                content.appendChild(card);
            });
            resultsArea.appendChild(div);
        });
    }

    function downloadExcel() {
        if(!processingGroups.length) return;
        let data = [];
        processingGroups.forEach((g, idx) => {
            const gName = `Group_${String(idx+1).padStart(2,'0')}`;
            g.files.forEach(f => data.push({ "ç¾¤çµ„": gName, "æª”å": f.name }));
        });
        const ws = XLSX.utils.json_to_sheet(data);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Result");
        XLSX.writeFile(wb, `åˆ†é¡çµæœ_${currentMode}.xlsx`);
    }

    function downloadZip() {
        if(!processingGroups.length) return;
        statusLog.textContent = "æ‰“åŒ…ä¸­...";
        const zip = new JSZip();
        processingGroups.forEach((g, idx) => {
            const folder = zip.folder(`Group_${String(idx+1).padStart(2,'0')}`);
            g.files.forEach(f => folder.file(f.name, f.file));
        });
        zip.generateAsync({type:"blob"}).then(content => {
            saveAs(content, `åˆ†é¡åœ–ç‰‡_${currentMode}.zip`);
            statusLog.textContent = "ä¸‹è¼‰é–‹å§‹ï¼";
        });
    }
</script>

</body>
</html>
