<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>六邊形遊戲圖形歸類器 (Web版)</title>
    <style>
        :root {
            --primary: #2563eb;
            --bg: #f1f5f9;
            --card: #ffffff;
            --text: #1e293b;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            padding: 2rem;
            max-width: 1000px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .card {
            background: var(--card);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            margin-bottom: 1.5rem;
        }

        .upload-area {
            border: 2px dashed #cbd5e1;
            border-radius: 8px;
            padding: 3rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover, .upload-area.dragover {
            border-color: var(--primary);
            background-color: #eff6ff;
        }

        .btn {
            background-color: var(--primary);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            margin-top: 1rem;
        }
        
        .btn:disabled { background-color: #94a3b8; cursor: not-allowed; }
        .btn.download { background-color: #059669; display: none; }

        .progress-bar {
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin: 1rem 0;
            overflow: hidden;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        #status {
            color: #64748b;
            font-size: 0.9rem;
            white-space: pre-wrap;
            font-family: monospace;
            max-height: 150px;
            overflow-y: auto;
        }

        /* Result Group Styling */
        .group-container {
            margin-top: 20px;
        }
        .group-block {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin-bottom: 15px;
            overflow: hidden;
        }
        .group-header {
            background: #f8fafc;
            padding: 10px 15px;
            font-weight: bold;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
        }
        .group-content {
            padding: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .img-thumb {
            width: 80px;
            height: 80px;
            object-fit: contain;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        .img-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90px;
        }
        .img-name {
            font-size: 0.7rem;
            color: #666;
            margin-top: 4px;
            text-align: center;
            word-break: break-all;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            width: 100%;
        }
    </style>
</head>
<body>

<div class="header">
    <h1>六邊形結構自動歸類器</h1>
    <p>忽略顏色差異 • 自動旋轉比對 • 純前端處理</p>
</div>

<div class="card">
    <div class="upload-area" id="dropZone">
        <h3>點擊選擇或拖曳圖片至此</h3>
        <p style="color: #64748b;">支援 .png, .jpg (建議一次選取大量圖片)</p>
        <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
    </div>

    <div class="progress-bar" id="progressContainer">
        <div class="progress-fill" id="progressBar"></div>
    </div>
    
    <div style="display: flex; gap: 10px; justify-content: center;">
        <button id="processBtn" class="btn" disabled>開始處理</button>
        <button id="downloadBtn" class="btn download">下載 CSV 分組結果</button>
    </div>

    <div id="status" style="margin-top: 15px;"></div>
</div>

<div id="resultArea" class="card" style="display: none;">
    <h2>分組預覽</h2>
    <div id="groupsDisplay" class="group-container"></div>
</div>

<script>
    // --- 參數設定 ---
    const HASH_SIZE = 16; // 16x16 = 256 bits
    const BINARY_THRESHOLD = 200; // 亮度 > 200 視為白色(背景)，否則為黑色(線條)
    // 六邊形旋轉角度
    const ANGLES = [0, 60, 120, 180, 240, 300];

    // --- DOM 元素 ---
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const processBtn = document.getElementById('processBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusBox = document.getElementById('status');
    const progressBar = document.getElementById('progressBar');
    const progressContainer = document.getElementById('progressContainer');
    const resultArea = document.getElementById('resultArea');
    const groupsDisplay = document.getElementById('groupsDisplay');

    let selectedFiles = [];
    let groupResults = [];

    // --- 事件監聽 ---
    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        handleFiles(e.dataTransfer.files);
    });
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
    processBtn.addEventListener('click', startProcessing);
    downloadBtn.addEventListener('click', downloadCSV);

    function log(msg) {
        statusBox.textContent = msg;
    }

    function handleFiles(files) {
        selectedFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
        if (selectedFiles.length > 0) {
            log(`已選擇 ${selectedFiles.length} 張圖片。準備就緒。`);
            processBtn.disabled = false;
            processBtn.textContent = `開始處理 ${selectedFiles.length} 張圖片`;
            resultArea.style.display = 'none';
            downloadBtn.style.display = 'none';
        } else {
            log("請選擇有效的圖片檔案。");
        }
    }

    // --- 核心邏輯：圖像處理 ---

    // 1. 讀取圖片
    function loadImage(file) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.src = URL.createObjectURL(file);
        });
    }

    // 2. 預處理：Pad成正方形 -> 二值化 (消除顏色)
    function getPreprocessedCanvas(img) {
        const w = img.naturalWidth;
        const h = img.naturalHeight;
        const size = Math.max(w, h);

        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // 填白底 (避免透明背景干擾)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, size, size);

        // 居中繪製
        ctx.drawImage(img, (size - w) / 2, (size - h) / 2);

        // 取得像素數據進行二值化
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            // 計算灰階 (R,G,B 加權)
            const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            // 二值化：大於閾值變白，小於變黑 (消除顏色差異，只留線條結構)
            const val = gray > BINARY_THRESHOLD ? 255 : 0;
            
            data[i] = val;     // R
            data[i+1] = val;   // G
            data[i+2] = val;   // B
            // Alpha 不變
        }
        ctx.putImageData(imageData, 0, 0);
        return canvas;
    }

    // 3. 旋轉 Canvas
    function getRotatedCanvas(sourceCanvas, angleDeg) {
        if (angleDeg === 0) return sourceCanvas;
        
        const size = sourceCanvas.width; // 已經是正方形
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, size, size);

        ctx.translate(size / 2, size / 2);
        ctx.rotate(angleDeg * Math.PI / 180);
        ctx.drawImage(sourceCanvas, -size / 2, -size / 2);

        return canvas;
    }

    // 4. 計算 Hash (縮圖 -> 比較像素)
    function calculateHash(canvas) {
        // 縮圖到 HASH_SIZE (例如 16x16)
        const smallCanvas = document.createElement('canvas');
        smallCanvas.width = HASH_SIZE;
        smallCanvas.height = HASH_SIZE;
        const ctx = smallCanvas.getContext('2d');
        
        // 使用高品質縮放 (類似 Python 的 Lanczos)
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(canvas, 0, 0, HASH_SIZE, HASH_SIZE);

        const data = ctx.getImageData(0, 0, HASH_SIZE, HASH_SIZE).data;
        let pixels = [];
        let sum = 0;

        // 取出灰階值
        for(let i=0; i<data.length; i+=4) {
            const val = data[i]; // 已二值化，R=G=B
            pixels.push(val);
            sum += val;
        }

        const avg = sum / pixels.length;
        let hashStr = "";
        
        // 產生指紋字串
        for(let p of pixels) {
            hashStr += (p > avg) ? "1" : "0";
        }
        
        return hashStr;
    }

    // --- 主流程 ---

    async function startProcessing() {
        processBtn.disabled = true;
        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';
        groupsDisplay.innerHTML = '';
        
        let fileHashes = {}; // { fileName: minHashStr }
        let processedCount = 0;

        // 1. 計算每張圖的「最小旋轉 Hash」
        for (const file of selectedFiles) {
            try {
                const img = await loadImage(file);
                // 轉黑白 + 正方形
                const baseCanvas = getPreprocessedCanvas(img);
                
                let minHash = null;
                // 嘗試 6 個角度，找最小的 Hash (Canonical Hash)
                for (const angle of ANGLES) {
                    const rotCanvas = getRotatedCanvas(baseCanvas, angle);
                    const hash = calculateHash(rotCanvas);
                    
                    // 字串比對找最小 (Lexicographically smallest)
                    if (minHash === null || hash < minHash) {
                        minHash = hash;
                    }
                }
                fileHashes[file.name] = minHash;

            } catch (err) {
                console.error(err);
            }

            processedCount++;
            const pct = Math.round((processedCount / selectedFiles.length) * 100);
            progressBar.style.width = `${pct}%`;
            log(`正在處理 (${processedCount}/${selectedFiles.length}): ${file.name}`);
            
            // 讓出線程，避免 UI 卡死
            await new Promise(r => setTimeout(r, 0));
        }

        // 2. 分組 (完全匹配 Hash)
        // 註：Python 版用了 Hamming Distance，但在「二值化」且「結構單純」的情況下，
        // Hash 通常會完全一致。若需要容錯，可在這裡加入距離計算，但前端做 N^2 比對會較慢。
        // 這裡我們先做「精確匹配」，因為二值化已經過濾了大部分雜訊。
        
        let groups = {}; // { hash: [fileName, ...] }
        for (let name in fileHashes) {
            const h = fileHashes[name];
            if (!groups[h]) groups[h] = [];
            groups[h].push(name);
        }

        // 整理結果
        groupResults = Object.values(groups).sort((a, b) => b.length - a.length); // 依數量排序
        
        renderResults(groupResults);
        
        log(`處理完成！共分類為 ${groupResults.length} 組。`);
        processBtn.disabled = false;
        processBtn.textContent = '重新處理';
        downloadBtn.style.display = 'inline-block';
        resultArea.style.display = 'block';
    }

    function renderResults(groups) {
        groups.forEach((files, index) => {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'group-block';
            
            const header = document.createElement('div');
            header.className = 'group-header';
            header.innerHTML = `<span>Group ${index + 1}</span> <span>${files.length} 張圖片</span>`;
            
            const content = document.createElement('div');
            content.className = 'group-content';
            
            files.slice(0, 10).forEach(fname => { // 預覽最多顯示 10 張
                // 為了顯示圖片，我們需要找回原本的 File 物件
                const fileObj = selectedFiles.find(f => f.name === fname);
                if(fileObj) {
                    const wrap = document.createElement('div');
                    wrap.className = 'img-item';
                    
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(fileObj);
                    img.className = 'img-thumb';
                    
                    const name = document.createElement('div');
                    name.className = 'img-name';
                    name.textContent = fname;
                    
                    wrap.appendChild(img);
                    wrap.appendChild(name);
                    content.appendChild(wrap);
                }
            });

            if (files.length > 10) {
                const more = document.createElement('div');
                more.style.alignSelf = 'center';
                more.style.color = '#666';
                more.textContent = `...還有 ${files.length - 10} 張`;
                content.appendChild(more);
            }

            groupDiv.appendChild(header);
            groupDiv.appendChild(content);
            groupsDisplay.appendChild(groupDiv);
        });
    }

    function downloadCSV() {
        let csv = "Group_ID,Files\n";
        groupResults.forEach((files, index) => {
            const groupName = `Group_${index + 1}`;
            const fileList = files.join(" ");
            csv += `${groupName},"${fileList}"\n`;
        });

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'game_grouping_results.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }
</script>

</body>
</html>
