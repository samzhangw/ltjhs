<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI å…­é‚Šå½¢çµæ§‹æ­¸é¡å™¨ (Pro é«˜æº–ç¢ºç‰ˆ)</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style>
        :root {
            --primary: #2563eb;
            --surface: rgba(255, 255, 255, 0.95);
            --bg-gradient: linear-gradient(135deg, #f0f9ff 0%, #e0e7ff 100%);
            --border: #cbd5e1;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-gradient);
            color: #1e293b;
            margin: 0;
            padding: 40px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            background: var(--surface);
            padding: 2.5rem;
            border-radius: 20px;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.6);
        }

        h1 { text-align: center; color: var(--primary); margin-bottom: 0.5rem; }
        .desc { text-align: center; color: #64748b; margin-bottom: 2rem; font-size: 0.95rem; }

        .upload-area {
            border: 3px dashed #94a3b8;
            border-radius: 12px;
            padding: 3rem;
            text-align: center;
            cursor: pointer;
            background: #f8fafc;
            transition: 0.2s;
        }
        .upload-area:hover { border-color: var(--primary); background: #eff6ff; }
        .upload-icon { font-size: 3rem; margin-bottom: 1rem; }

        .controls {
            display: flex; gap: 20px; justify-content: center; margin: 20px 0; flex-wrap: wrap;
            background: #f1f5f9; padding: 15px; border-radius: 10px;
        }
        .control-item { display: flex; align-items: center; gap: 10px; }
        input[type="number"] { width: 60px; padding: 5px; border-radius: 5px; border: 1px solid #ccc; text-align: center; }

        .btn-group { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
        button {
            padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; color: white; font-weight: 600;
            transition: 0.2s; display: flex; align-items: center; gap: 5px;
        }
        .btn-primary { background: var(--primary); }
        .btn-excel { background: #10b981; display: none; }
        .btn-zip { background: #f59e0b; display: none; }
        button:disabled { background: #cbd5e1; cursor: not-allowed; }
        button:hover:not(:disabled) { transform: translateY(-2px); opacity: 0.9; }

        .progress-bar {
            height: 6px; background: var(--primary); width: 0%; margin-top: 15px; border-radius: 3px; transition: width 0.3s;
        }

        .results { margin-top: 30px; display: grid; gap: 20px; }
        .group-block {
            background: white; border: 1px solid var(--border); border-radius: 12px; overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
        }
        .group-header {
            padding: 12px 20px; background: #f8fafc; border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; font-weight: bold;
        }
        .group-content {
            padding: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 10px;
            max-height: 350px; overflow-y: auto;
        }
        .img-card { text-align: center; cursor: pointer; transition: 0.2s; }
        .img-card:hover { transform: scale(1.05); }
        .img-thumb {
            width: 100%; aspect-ratio: 1; object-fit: contain; border: 1px solid #eee; border-radius: 6px; padding: 2px;
        }
        .img-name { font-size: 11px; color: #666; margin-top: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        /* Modal */
        .modal {
            display: none; position: fixed; z-index: 999; left: 0; top: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); align-items: center; justify-content: center;
        }
        .modal img { max-width: 90%; max-height: 90%; border-radius: 8px; box-shadow: 0 0 20px rgba(255,255,255,0.2); }
        .modal-close { position: absolute; top: 20px; right: 30px; color: white; font-size: 40px; cursor: pointer; }
    </style>
</head>
<body>

<div class="container">
    <h1>ğŸ§© å…­é‚Šå½¢çµæ§‹æ­¸é¡å™¨ (Pro é«˜æº–ç¢ºç‰ˆ)</h1>
    <p class="desc">æ–°å¢æ¼”ç®—æ³•ï¼šè‡ªå‹•è£åˆ‡å±…ä¸­å°é½Š + æ™ºæ…§é™å™ª</p>

    <div class="upload-area" id="dropZone">
        <div class="upload-icon">ğŸ“‚</div>
        <h3>æ‹–æ›³åœ–ç‰‡åˆ°é€™è£¡</h3>
        <p>å»ºè­°ä¸€æ¬¡å…¨é¸ä¸Šå‚³ï¼Œè‡ªå‹•åˆ†æå¹¾ä½•çµæ§‹</p>
        <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
    </div>

    <div class="controls">
        <div class="control-item">
            <label title="å®¹è¨±å¤šå°‘å€‹åƒç´ ç‰¹å¾µä¸åŒã€‚è¨­ç‚º 0 æœ€åš´æ ¼ï¼Œè¨­ç‚º 5 è¼ƒå¯¬é¬†">å®¹è¨±å·®ç•° (Distance):</label>
            <input type="number" id="thresholdInput" value="3" min="0" max="20">
        </div>
        <div class="control-item">
            <label title="ç‰¹å¾µåœ–å¤§å°ï¼Œè¶Šå¤§è¶Šç²¾ç´°ã€‚å»ºè­° 16 æˆ– 24">ç‰¹å¾µç²¾åº¦ (Hash Size):</label>
            <input type="number" id="hashSizeInput" value="16" min="8" max="32">
        </div>
    </div>

    <div class="btn-group">
        <button id="processBtn" class="btn-primary" disabled>ğŸš€ é–‹å§‹ç²¾æº–åˆ†æ</button>
        <button id="excelBtn" class="btn-excel">ğŸ“Š ä¸‹è¼‰ Excel</button>
        <button id="zipBtn" class="btn-zip">ğŸ“¦ ä¸‹è¼‰æ­¸é¡ ZIP</button>
    </div>

    <div style="width: 100%; background: #e2e8f0; border-radius: 3px; margin-top: 15px; display: none;" id="progressWrap">
        <div class="progress-bar" id="progressBar"></div>
    </div>
    <div id="statusLog" style="text-align: center; margin-top: 10px; color: #64748b; font-size: 0.9rem;">ç­‰å¾…åœ–ç‰‡...</div>

    <div id="resultsArea" class="results"></div>
</div>

<div id="imgModal" class="modal" onclick="this.style.display='none'">
    <span class="modal-close">&times;</span>
    <img id="modalImg">
</div>

<script>
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const processBtn = document.getElementById('processBtn');
    const excelBtn = document.getElementById('excelBtn');
    const zipBtn = document.getElementById('zipBtn');
    const statusLog = document.getElementById('statusLog');
    const progressBar = document.getElementById('progressBar');
    const progressWrap = document.getElementById('progressWrap');
    const resultsArea = document.getElementById('resultsArea');
    const modal = document.getElementById('imgModal');
    const modalImg = document.getElementById('modalImg');

    let selectedFiles = [];
    let processingGroups = [];
    
    // è¨­å®š
    const ANGLES = [0, 60, 120, 180, 240, 300];
    const BINARY_THRESHOLD = 180; // ç¨å¾®èª¿ä½é–¾å€¼ï¼Œç¢ºä¿æ·ºè‰²ç·šæ¢èƒ½è¢«æ•æ‰

    // äº‹ä»¶
    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.borderColor = '#2563eb'; });
    dropZone.addEventListener('dragleave', () => { dropZone.style.borderColor = '#94a3b8'; });
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.style.borderColor = '#94a3b8'; handleFiles(e.dataTransfer.files); });
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
    processBtn.addEventListener('click', startAnalysis);
    excelBtn.addEventListener('click', downloadExcel);
    zipBtn.addEventListener('click', downloadZip);

    function handleFiles(files) {
        const imgs = Array.from(files).filter(f => f.type.startsWith('image/'));
        if (!imgs.length) return;
        selectedFiles = [...selectedFiles, ...imgs];
        statusLog.textContent = `å·²è¼‰å…¥ ${selectedFiles.length} å¼µåœ–ç‰‡`;
        processBtn.disabled = false;
        excelBtn.style.display = 'none';
        zipBtn.style.display = 'none';
        resultsArea.innerHTML = '';
    }

    function loadImage(file) {
        return new Promise(resolve => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.src = URL.createObjectURL(file);
        });
    }

    // â˜…â˜…â˜… æ ¸å¿ƒå‡ç´šï¼šè‡ªå‹•è£åˆ‡èˆ‡å±…ä¸­ (Auto-Crop & Center) â˜…â˜…â˜…
    function preprocessImage(img, targetSize) {
        // 1. å…ˆç¹ªè£½åˆ°æš«å­˜ Canvas é€²è¡Œåˆæ­¥äºŒå€¼åŒ–èˆ‡åˆ†æ
        const w = img.naturalWidth, h = img.naturalHeight;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = w; tempCanvas.height = h;
        const ctx = tempCanvas.getContext('2d');
        
        // ç•«ç™½åº•
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, w, h);
        
        // è¼•å¾®æ¨¡ç³Š (é™å™ª)
        ctx.filter = 'blur(1px)'; 
        ctx.drawImage(img, 0, 0);
        ctx.filter = 'none'; // é‡ç½® filter

        const imgData = ctx.getImageData(0, 0, w, h);
        const data = imgData.data;

        // 2. å°‹æ‰¾å…§å®¹é‚Šç•Œ (Bounding Box)
        let minX = w, minY = h, maxX = 0, maxY = 0;
        let hasContent = false;

        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const i = (y * w + x) * 4;
                // è¨ˆç®—äº®åº¦
                const gray = data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114;
                
                // å¦‚æœæ˜¯æ·±è‰²åƒç´  (å…§å®¹)
                if (gray < BINARY_THRESHOLD) {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                    hasContent = true;
                }
            }
        }

        // å¦‚æœæ˜¯ä¸€å¼µå…¨ç™½åœ–ï¼Œå°±é è¨­å…¨åœ–
        if (!hasContent) { minX = 0; minY = 0; maxX = w; maxY = h; }

        // å…§å®¹å¯¬é«˜
        const contentW = maxX - minX;
        const contentH = maxY - minY;
        const maxContentDim = Math.max(contentW, contentH);

        // 3. å»ºç«‹æœ€çµ‚çš„æ­£æ–¹å½¢ Canvasï¼Œå°‡å…§å®¹ã€Œç½®ä¸­ã€ç¹ªè£½
        const finalCanvas = document.createElement('canvas');
        finalCanvas.width = targetSize;
        finalCanvas.height = targetSize;
        const fCtx = finalCanvas.getContext('2d');

        // å¡«ç™½
        fCtx.fillStyle = '#FFFFFF';
        fCtx.fillRect(0, 0, targetSize, targetSize);

        // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ (ç•™ä¸€é»é‚Šè· padding)
        const padding = targetSize * 0.1; 
        const scale = (targetSize - padding * 2) / maxContentDim;
        
        // å°‡è£åˆ‡å¾Œçš„å…§å®¹ç¸®æ”¾ä¸¦ç½®ä¸­è²¼ä¸Š
        fCtx.drawImage(
            tempCanvas, 
            minX, minY, contentW, contentH, // ä¾†æºè£åˆ‡
            (targetSize - contentW * scale) / 2, (targetSize - contentH * scale) / 2, // ç›®æ¨™ä½ç½® (ç½®ä¸­)
            contentW * scale, contentH * scale // ç›®æ¨™å¤§å°
        );

        // 4. æœ€çµ‚äºŒå€¼åŒ– (Sharp Binarization)
        const finalData = fCtx.getImageData(0, 0, targetSize, targetSize);
        const d = finalData.data;
        for (let i = 0; i < d.length; i += 4) {
            const g = d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114;
            const val = g > BINARY_THRESHOLD ? 255 : 0;
            d[i] = val; d[i+1] = val; d[i+2] = val;
        }
        fCtx.putImageData(finalData, 0, 0);

        return finalCanvas;
    }

    function getRotatedCanvas(source, angle) {
        if (angle === 0) return source;
        const size = source.width;
        const c = document.createElement('canvas');
        c.width = size; c.height = size;
        const ctx = c.getContext('2d');
        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, size, size);
        ctx.translate(size/2, size/2);
        ctx.rotate(angle * Math.PI / 180);
        ctx.drawImage(source, -size/2, -size/2);
        return c;
    }

    function calculateHash(canvas, hashSize) {
        const c = document.createElement('canvas');
        c.width = hashSize; c.height = hashSize;
        const ctx = c.getContext('2d');
        ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(canvas, 0, 0, hashSize, hashSize);
        const d = ctx.getImageData(0, 0, hashSize, hashSize).data;
        let pixels = [], sum = 0;
        for (let i = 0; i < d.length; i+=4) { pixels.push(d[i]); sum += d[i]; }
        const avg = sum / pixels.length;
        return pixels.map(p => p > avg ? '1' : '0').join('');
    }

    function hammingDistance(s1, s2) {
        let dist = 0;
        for(let i=0; i<s1.length; i++) if(s1[i]!==s2[i]) dist++;
        return dist;
    }

    async function startAnalysis() {
        if(!selectedFiles.length) return;
        processBtn.disabled = true;
        progressWrap.style.display = 'block';
        resultsArea.innerHTML = '';
        
        const hashSize = parseInt(document.getElementById('hashSizeInput').value) || 16;
        const threshold = parseInt(document.getElementById('thresholdInput').value) || 3;
        
        // é€™è£¡è¨­å®šå…§éƒ¨è™•ç†çš„è§£æåº¦ï¼Œå¤ å¤§æ‰èƒ½ç¢ºä¿è£åˆ‡æº–ç¢º
        const PROCESSING_SIZE = 200; 
        let fileData = [];

        // éšæ®µä¸€ï¼šç‰¹å¾µæå–
        for(let i=0; i<selectedFiles.length; i++){
            statusLog.textContent = `è™•ç†ä¸­ï¼š${selectedFiles[i].name} (${i+1}/${selectedFiles.length})`;
            progressBar.style.width = `${((i+1)/selectedFiles.length)*50}%`;

            try {
                const img = await loadImage(selectedFiles[i]);
                // ä½¿ç”¨æ–°çš„é è™•ç†å‡½æ•¸ (å«è£åˆ‡ã€å±…ä¸­ã€æ¨¡ç³Š)
                const baseCanvas = preprocessImage(img, PROCESSING_SIZE);
                
                let minHash = null;
                for(const angle of ANGLES) {
                    const rot = getRotatedCanvas(baseCanvas, angle);
                    const h = calculateHash(rot, hashSize);
                    if(minHash === null || h < minHash) minHash = h;
                }
                fileData.push({ file: selectedFiles[i], hash: minHash, name: selectedFiles[i].name });
            } catch(e) { console.error(e); }
            await new Promise(r => setTimeout(r, 0));
        }

        // éšæ®µäºŒï¼šåˆ†ç¾¤
        statusLog.textContent = "æ­£åœ¨é€²è¡Œæ™ºæ…§æ¯”å°...";
        let groups = [];
        for(let i=0; i<fileData.length; i++){
            const item = fileData[i];
            let match = null;
            // å°‹æ‰¾æœ€æ¥è¿‘çš„ç¾¤çµ„
            for(let g of groups) {
                if(hammingDistance(item.hash, g.repHash) <= threshold) {
                    match = g; break;
                }
            }
            if(match) match.files.push(item);
            else groups.push({ repHash: item.hash, files: [item] });
            
            progressBar.style.width = `${50 + ((i+1)/fileData.length)*50}%`;
        }

        groups.sort((a,b) => b.files.length - a.files.length);
        processingGroups = groups;
        renderResults(groups);

        statusLog.textContent = `å®Œæˆï¼å…± ${groups.length} çµ„`;
        processBtn.textContent = 'é‡æ–°åˆ†æ';
        processBtn.disabled = false;
        excelBtn.style.display = 'block';
        zipBtn.style.display = 'block';
    }

    function renderResults(groups) {
        resultsArea.innerHTML = '';
        groups.forEach((g, idx) => {
            const div = document.createElement('div');
            div.className = 'group-block';
            div.innerHTML = `
                <div class="group-header">
                    <span>Group ${idx+1}</span>
                    <span style="background:#e0e7ff; color:#2563eb; padding:2px 8px; border-radius:10px; font-size:12px;">${g.files.length} å¼µ</span>
                </div>
                <div class="group-content"></div>
            `;
            const content = div.querySelector('.group-content');
            g.files.forEach(f => {
                const card = document.createElement('div');
                card.className = 'img-card';
                card.onclick = () => { modal.style.display='flex'; modalImg.src=URL.createObjectURL(f.file); };
                card.innerHTML = `<img class="img-thumb" src="${URL.createObjectURL(f.file)}"><div class="img-name">${f.name}</div>`;
                content.appendChild(card);
            });
            resultsArea.appendChild(div);
        });
    }

    function downloadExcel() {
        if(!processingGroups.length) return;
        let data = [];
        processingGroups.forEach((g, idx) => {
            const gName = `Group_${String(idx+1).padStart(2,'0')}`;
            g.files.forEach(f => data.push({ "ç¾¤çµ„": gName, "æª”å": f.name }));
        });
        const ws = XLSX.utils.json_to_sheet(data);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Result");
        XLSX.writeFile(wb, "å…­é‚Šå½¢æ­¸é¡å ±å‘Š.xlsx");
    }

    function downloadZip() {
        if(!processingGroups.length) return;
        statusLog.textContent = "ğŸ“¦ æ‰“åŒ…ä¸­ï¼Œè«‹ç¨å€™...";
        const zip = new JSZip();
        processingGroups.forEach((g, idx) => {
            const folder = zip.folder(`Group_${String(idx+1).padStart(2,'0')}`);
            g.files.forEach(f => folder.file(f.name, f.file));
        });
        zip.generateAsync({type:"blob"}).then(content => {
            saveAs(content, "æ•´ç†å¥½çš„åœ–ç‰‡.zip");
            statusLog.textContent = "ä¸‹è¼‰å®Œæˆï¼";
        });
    }
</script>

</body>
</html>
