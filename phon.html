<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 賽局戰術分析工作站 (Pro版)</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style>
        :root { --primary: #4f46e5; --secondary: #818cf8; --bg: #f8fafc; --surface: #ffffff; --text: #1e293b; }
        body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text); padding: 40px 20px; margin: 0; }
        .container { max-width: 1400px; margin: 0 auto; }

        /* 標題與說明 */
        header { text-align: center; margin-bottom: 40px; }
        h1 { font-size: 2.5rem; color: var(--primary); margin-bottom: 10px; display: flex; align-items: center; justify-content: center; gap: 15px; }
        .desc { color: #64748b; font-size: 1.1rem; }

        /* 上傳區塊 */
        .upload-card {
            background: var(--surface); border: 2px dashed #cbd5e1; border-radius: 16px;
            padding: 3rem; text-align: center; cursor: pointer; transition: 0.3s;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
        }
        .upload-card:hover { border-color: var(--primary); background: #eef2ff; transform: translateY(-2px); }
        .upload-icon { font-size: 3rem; color: var(--primary); margin-bottom: 1rem; }

        /* 控制面板 */
        .main-controls { display: flex; gap: 15px; justify-content: center; margin: 30px 0; }
        .btn {
            padding: 12px 28px; border: none; border-radius: 8px; font-weight: 600; font-size: 1rem;
            cursor: pointer; transition: 0.2s; display: flex; align-items: center; gap: 8px;
        }
        .btn-primary { background: var(--primary); color: white; box-shadow: 0 4px 6px -1px rgba(79, 70, 229, 0.3); }
        .btn-primary:hover:not(:disabled) { background: #4338ca; transform: translateY(-1px); }
        .btn-success { background: #10b981; color: white; display: none; }
        .btn-success:hover { background: #059669; }
        .btn:disabled { background: #cbd5e1; cursor: not-allowed; box-shadow: none; }

        /* 分析結果區 */
        .results-grid { display: flex; flex-direction: column; gap: 40px; }

        /* 策略群組卡片 (核心介面) */
        .strategy-card {
            background: var(--surface); border-radius: 20px; overflow: hidden;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1); border-top: 6px solid var(--primary);
            animation: fadeIn 0.5s ease-out;
        }

        .card-header {
            padding: 20px 30px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center;
            background: #fff;
        }
        .group-title { font-size: 1.4rem; font-weight: 700; color: #0f172a; display: flex; align-items: center; gap: 10px; }
        .badge { background: #e0e7ff; color: var(--primary); padding: 4px 12px; border-radius: 20px; font-size: 0.9rem; font-weight: bold; }

        /* 播放器佈局 */
        .player-layout { display: grid; grid-template-columns: 350px 1fr; gap: 0; border-bottom: 1px solid #e2e8f0; }
        
        /* 左側：資訊與筆記 */
        .player-sidebar { padding: 25px; background: #f8fafc; border-right: 1px solid #e2e8f0; display: flex; flex-direction: column; gap: 20px; }
        .game-list-box {
            max-height: 200px; overflow-y: auto; background: white; border: 1px solid #cbd5e1; border-radius: 8px; padding: 10px;
        }
        .game-item { padding: 6px 10px; font-size: 0.9rem; color: #475569; border-bottom: 1px solid #f1f5f9; }
        .game-item:last-child { border-bottom: none; }
        
        .note-area {
            width: 100%; height: 120px; padding: 12px; border: 1px solid #cbd5e1; border-radius: 8px;
            font-family: inherit; resize: none; outline: none; transition: 0.2s; box-sizing: border-box;
        }
        .note-area:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1); }

        /* 右側：主螢幕 */
        .player-stage { padding: 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #0f172a; position: relative; }
        .main-screen {
            height: 400px; width: 100%; object-fit: contain; border-radius: 4px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5); background: white;
        }
        .turn-indicator {
            position: absolute; top: 30px; right: 30px; background: rgba(0,0,0,0.7); color: white;
            padding: 5px 15px; border-radius: 20px; font-weight: bold; font-family: monospace; font-size: 1.2rem;
        }

        /* 播放控制列 */
        .control-bar {
            background: #1e293b; width: 100%; padding: 10px 30px; display: flex; align-items: center; justify-content: center; gap: 20px;
        }
        .ctrl-btn {
            background: transparent; border: 2px solid #475569; color: #cbd5e1; width: 40px; height: 40px; border-radius: 50%;
            cursor: pointer; transition: 0.2s; display: flex; align-items: center; justify-content: center;
        }
        .ctrl-btn:hover { border-color: white; color: white; background: rgba(255,255,255,0.1); }
        .ctrl-btn.active { background: var(--primary); border-color: var(--primary); color: white; }
        
        /* 底部：時間軸縮圖 */
        .timeline-strip {
            padding: 20px; overflow-x: auto; white-space: nowrap; background: #fff;
            display: flex; gap: 15px; align-items: center;
        }
        .timeline-strip::-webkit-scrollbar { height: 8px; }
        .timeline-strip::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }

        .thumb-item {
            display: inline-block; width: 80px; text-align: center; cursor: pointer; opacity: 0.6; transition: 0.2s; position: relative;
        }
        .thumb-item img {
            width: 80px; height: 80px; object-fit: contain; border: 2px solid #e2e8f0; border-radius: 6px;
        }
        .thumb-item.active { opacity: 1; transform: scale(1.1); }
        .thumb-item.active img { border-color: var(--primary); }
        .arrow { color: #cbd5e1; font-weight: bold; font-size: 1.2rem; margin-top: -20px; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1><i class="fa-solid fa-chess-board"></i> AI 賽局戰術分析工作站</h1>
        <p class="desc">自動歸類相似開局，支援即時播放演示與戰術筆記撰寫</p>
    </header>

    <div class="upload-card" id="dropZone">
        <div class="upload-icon"><i class="fa-solid fa-cloud-arrow-up"></i></div>
        <h3>拖曳圖片到這裡上傳</h3>
        <p style="color:#94a3b8">請全選所有 Game_XXX_Turn_YYY 圖片 (支援多局)</p>
        <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
    </div>

    <div class="main-controls">
        <button id="analyzeBtn" class="btn btn-primary" disabled>
            <i class="fa-solid fa-wand-magic-sparkles"></i> 開始戰術分析
        </button>
        <button id="downloadBtn" class="btn btn-success">
            <i class="fa-solid fa-file-excel"></i> 匯出分析報告 (含筆記)
        </button>
    </div>

    <div id="statusLog" style="text-align: center; color: #64748b; margin-bottom: 20px;"></div>
    <div id="resultsArea" class="results-grid"></div>
</div>

<script>
    // --- 全域變數 ---
    let uploadedFiles = [];
    let clusteredGroups = [];
    let gameDataGlobal = {}; // 全域儲存處理後的圖片 Blob URL
    let playbackIntervals = {}; // 儲存每個播放器的 interval ID
    const IMG_SIZE = 150;
    const ANGLES = [0, 60, 120, 180, 240, 300];

    // --- DOM 元素 ---
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusLog = document.getElementById('statusLog');
    const resultsArea = document.getElementById('resultsArea');

    // --- 1. 檔案上傳處理 ---
    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.background = '#eef2ff'; });
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.style.background = '#ffffff'; handleFiles(e.dataTransfer.files); });
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

    function handleFiles(files) {
        const imgs = Array.from(files).filter(f => f.type.startsWith('image/'));
        if (!imgs.length) return;
        uploadedFiles = [...uploadedFiles, ...imgs];
        statusLog.innerHTML = `<i class="fa-solid fa-check-circle"></i> 已載入 ${uploadedFiles.length} 張圖片`;
        analyzeBtn.disabled = false;
        resultsArea.innerHTML = '';
        downloadBtn.style.display = 'none';
    }

    // --- 2. 主分析流程 ---
    analyzeBtn.addEventListener('click', async () => {
        analyzeBtn.disabled = true;
        statusLog.textContent = "正在解析棋局結構與計算特徵...";
        resultsArea.innerHTML = '';
        gameDataGlobal = {};

        // A. 整理圖片資料
        const tempGameData = {};
        uploadedFiles.forEach(file => {
            const match = file.name.match(/Game_(\d+)_Turn_(\d+)/i);
            if (match) {
                const gId = match[1];
                const tId = parseInt(match[2]);
                if (!tempGameData[gId]) tempGameData[gId] = {};
                tempGameData[gId][tId] = file;
            }
        });

        const gameIds = Object.keys(tempGameData).sort();
        if (gameIds.length === 0) {
            alert("錯誤：找不到符合 Game_XXX 格式的圖片");
            analyzeBtn.disabled = false;
            return;
        }

        // B. 計算特徵指紋
        const gameSignatures = {};
        for (let gId of gameIds) {
            const turns = Object.keys(tempGameData[gId]).map(Number).sort((a,b)=>a-b);
            const signature = [];
            
            // 儲存 blob url 供後續顯示
            gameDataGlobal[gId] = {};
            
            for (let t of turns) {
                const img = await loadImage(tempGameData[gId][t]);
                const hash = await getRotatedHash(img);
                signature.push({ turn: t, hash: hash });
                gameDataGlobal[gId][t] = URL.createObjectURL(tempGameData[gId][t]);
            }
            gameSignatures[gId] = signature;
        }

        // C. 執行分群
        clusteredGroups = performClustering(gameIds, gameSignatures);

        // D. 渲染介面
        renderGroups(clusteredGroups);

        statusLog.innerHTML = `<i class="fa-solid fa-check-double"></i> 分析完成！共發現 ${clusteredGroups.length} 種不同的戰術模式`;
        analyzeBtn.disabled = false;
        downloadBtn.style.display = 'inline-flex';
    });

    // --- 3. 演算法核心 ---
    function performClustering(gameIds, signatures) {
        const groups = [];
        const visited = new Set();
        const THRESHOLD = 5;

        for (let i = 0; i < gameIds.length; i++) {
            const currentId = gameIds[i];
            if (visited.has(currentId)) continue;
            const newGroup = { 
                id: `cluster_${Date.now()}_${i}`, // 唯一ID
                repId: currentId, 
                members: [currentId],
                signature: signatures[currentId] // 儲存特徵供長度參考
            };
            visited.add(currentId);

            for (let j = i + 1; j < gameIds.length; j++) {
                const targetId = gameIds[j];
                if (visited.has(targetId)) continue;
                if (isStrategySimilar(signatures[currentId], signatures[targetId], THRESHOLD)) {
                    newGroup.members.push(targetId);
                    visited.add(targetId);
                }
            }
            groups.push(newGroup);
        }
        return groups.sort((a,b) => b.members.length - a.members.length);
    }

    function isStrategySimilar(sigA, sigB, threshold) {
        const len = Math.min(sigA.length, sigB.length);
        if (len === 0) return false;
        for (let k = 0; k < len; k++) {
            if (sigA[k].turn !== sigB[k].turn) continue;
            if (hammingDist(sigA[k].hash, sigB[k].hash) > threshold) return false;
        }
        return true;
    }

    // --- 4. 介面渲染 (戰術工作站) ---
    function renderGroups(groups) {
        resultsArea.innerHTML = '';
        groups.forEach((group, idx) => {
            const repGameId = group.repId;
            const turns = Object.keys(gameDataGlobal[repGameId]).map(Number).sort((a,b)=>a-b);
            const maxTurn = turns[turns.length-1];
            
            // 建立卡片 HTML
            const card = document.createElement('div');
            card.className = 'strategy-card';
            card.innerHTML = `
                <div class="card-header">
                    <div class="group-title">
                        <i class="fa-solid fa-chess-rook" style="color:var(--primary)"></i>
                        戰術模式 ${idx + 1}
                        <span class="badge">${group.members.length} 場賽局</span>
                    </div>
                    <div style="color:#64748b; font-size:0.9rem;">
                        <i class="fa-regular fa-clock"></i> 持續回合: ${maxTurn}
                    </div>
                </div>

                <div class="player-layout">
                    <div class="player-sidebar">
                        <div>
                            <label style="font-weight:600; font-size:0.9rem; color:#475569; display:block; margin-bottom:8px;">
                                <i class="fa-solid fa-pen-to-square"></i> 戰術筆記
                            </label>
                            <textarea class="note-area" id="note_${group.id}" placeholder="請輸入關於此戰術的分析筆記...&#10;(例如: 藍方在第3回合搶佔中心是關鍵)"></textarea>
                        </div>
                        <div>
                            <label style="font-weight:600; font-size:0.9rem; color:#475569; display:block; margin-bottom:8px;">
                                <i class="fa-solid fa-list"></i> 包含賽局
                            </label>
                            <div class="game-list-box">
                                ${group.members.map(m => `<div class="game-item">Game ${m}</div>`).join('')}
                            </div>
                        </div>
                    </div>

                    <div>
                        <div class="player-stage">
                            <img src="${gameDataGlobal[repGameId][turns[0]]}" class="main-screen" id="screen_${group.id}">
                            <div class="turn-indicator" id="turn_label_${group.id}">Turn ${turns[0]}</div>
                        </div>
                        <div class="control-bar">
                            <button class="ctrl-btn" onclick="changeTurn('${group.id}', '${repGameId}', -1)" title="上一步"><i class="fa-solid fa-backward-step"></i></button>
                            <button class="ctrl-btn" id="play_${group.id}" onclick="togglePlay('${group.id}', '${repGameId}')" title="播放/暫停"><i class="fa-solid fa-play"></i></button>
                            <button class="ctrl-btn" onclick="changeTurn('${group.id}', '${repGameId}', 1)" title="下一步"><i class="fa-solid fa-forward-step"></i></button>
                        </div>
                    </div>
                </div>

                <div class="timeline-strip" id="timeline_${group.id}">
                    ${turns.map((t, i) => `
                        ${i > 0 ? '<div class="arrow">→</div>' : ''}
                        <div class="thumb-item ${i===0?'active':''}" id="thumb_${group.id}_${t}" onclick="jumpToTurn('${group.id}', '${repGameId}', ${t})">
                            <img src="${gameDataGlobal[repGameId][t]}">
                            <div style="font-size:0.8rem; margin-top:5px; font-weight:600; color:#64748b">T${t}</div>
                        </div>
                    `).join('')}
                </div>
            `;
            resultsArea.appendChild(card);
            
            // 初始化該群組的狀態資料
            group.currentTurnIdx = 0;
            group.turns = turns;
        });
    }

    // --- 5. 播放器控制邏輯 ---
    
    // 跳轉到特定回合
    window.jumpToTurn = function(groupId, gameId, turn) {
        const group = clusteredGroups.find(g => g.id === groupId);
        if(!group) return;

        const idx = group.turns.indexOf(turn);
        if(idx === -1) return;
        
        updatePlayerUI(group, gameId, idx);
    }

    // 上一步/下一步
    window.changeTurn = function(groupId, gameId, delta) {
        const group = clusteredGroups.find(g => g.id === groupId);
        if(!group) return;

        let newIdx = group.currentTurnIdx + delta;
        if(newIdx < 0) newIdx = 0;
        if(newIdx >= group.turns.length) newIdx = group.turns.length - 1;

        updatePlayerUI(group, gameId, newIdx);
    }

    // 播放/暫停
    window.togglePlay = function(groupId, gameId) {
        const btn = document.getElementById(`play_${groupId}`);
        const icon = btn.querySelector('i');
        const group = clusteredGroups.find(g => g.id === groupId);

        if(playbackIntervals[groupId]) {
            // 停止
            clearInterval(playbackIntervals[groupId]);
            delete playbackIntervals[groupId];
            icon.className = 'fa-solid fa-play';
            btn.classList.remove('active');
        } else {
            // 播放
            icon.className = 'fa-solid fa-pause';
            btn.classList.add('active');
            playbackIntervals[groupId] = setInterval(() => {
                let nextIdx = group.currentTurnIdx + 1;
                if(nextIdx >= group.turns.length) {
                    nextIdx = 0; // 循環播放
                }
                updatePlayerUI(group, gameId, nextIdx);
            }, 800); // 800ms 一步
        }
    }

    // 更新介面 (圖片、標籤、縮圖高亮)
    function updatePlayerUI(group, gameId, idx) {
        group.currentTurnIdx = idx;
        const turn = group.turns[idx];
        const url = gameDataGlobal[gameId][turn];

        // 更新主畫面
        document.getElementById(`screen_${group.id}`).src = url;
        document.getElementById(`turn_label_${group.id}`).textContent = `Turn ${turn}`;

        // 更新縮圖高亮
        const strip = document.getElementById(`timeline_${group.id}`);
        const oldActive = strip.querySelector('.thumb-item.active');
        if(oldActive) oldActive.classList.remove('active');
        
        const newActive = document.getElementById(`thumb_${group.id}_${turn}`);
        if(newActive) {
            newActive.classList.add('active');
            // 自動捲動縮圖列
            newActive.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
    }

    // --- 6. 匯出 Excel (含筆記) ---
    downloadBtn.addEventListener('click', () => {
        const wb = XLSX.utils.book_new();
        const data = [];

        clusteredGroups.forEach((group, idx) => {
            // 抓取筆記內容
            const note = document.getElementById(`note_${group.id}`).value;
            
            group.members.forEach(gameId => {
                data.push({
                    "戰術分組": `Pattern ${idx + 1}`,
                    "賽局 ID": `Game ${gameId}`,
                    "同組局數": group.members.length,
                    "代表局": group.repId === gameId ? "Yes" : "",
                    "戰術筆記": note // 將筆記加入 Excel
                });
            });
        });

        const ws = XLSX.utils.json_to_sheet(data);
        // 設定欄寬
        ws['!cols'] = [{wch:15}, {wch:15}, {wch:10}, {wch:10}, {wch:50}];
        
        XLSX.utils.book_append_sheet(wb, ws, "戰術分析報告");
        XLSX.writeFile(wb, `Game_Strategy_Analysis_${new Date().toISOString().slice(0,10)}.xlsx`);
    });

    // --- 影像處理工具函式 ---
    function loadImage(file) {
        return new Promise(resolve => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.src = URL.createObjectURL(file);
        });
    }
    function getRotatedHash(img) {
        const canvas = preprocessImage(img);
        let minHash = null;
        for (let angle of ANGLES) {
            const rotCanvas = rotateCanvas(canvas, angle);
            const hash = calculateHash(rotCanvas);
            if (minHash === null || hash < minHash) minHash = hash;
        }
        return minHash;
    }
    function preprocessImage(img) {
        const size = IMG_SIZE;
        const cvs = document.createElement('canvas');
        cvs.width = size; cvs.height = size;
        const ctx = cvs.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,size,size);
        const scale = Math.min(size/img.naturalWidth, size/img.naturalHeight) * 0.9;
        const w = img.naturalWidth * scale;
        const h = img.naturalHeight * scale;
        ctx.drawImage(img, (size-w)/2, (size-h)/2, w, h);
        return cvs;
    }
    function rotateCanvas(source, angle) {
        if (angle === 0) return source;
        const cvs = document.createElement('canvas');
        cvs.width = source.width; cvs.height = source.height;
        const ctx = cvs.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,cvs.width,cvs.height);
        ctx.translate(cvs.width/2, cvs.height/2);
        ctx.rotate(angle * Math.PI / 180);
        ctx.drawImage(source, -cvs.width/2, -cvs.height/2);
        return cvs;
    }
    function calculateHash(canvas) {
        const size = 16; 
        const cvs = document.createElement('canvas');
        cvs.width = size; cvs.height = size;
        const ctx = cvs.getContext('2d');
        ctx.drawImage(canvas, 0, 0, size, size);
        const data = ctx.getImageData(0, 0, size, size).data;
        let hash = "";
        for(let i=0; i<data.length; i+=4) {
            const r=data[i], g=data[i+1], b=data[i+2];
            if ((r+g+b)/3 > 220) hash += "0"; 
            else if (r > g+30 && r > b+30) hash += "1";
            else if (b > r+30 && b > g+30) hash += "2";
            else hash += "3";
        }
        return hash;
    }
    function hammingDist(s1, s2) {
        let d = 0;
        for(let i=0; i<s1.length; i++) if(s1[i]!==s2[i]) d++;
        return d;
    }
</script>
</body>
</html>
